js

阮一峰es6：https://es6.ruanyifeng.com/#docs/set-map

面试经常被问到的题
https://blog.csdn.net/xieanna123/article/details/105545758


1、什么是闭包，有哪些例子，优缺点是什么
利用函数作用域来保护私有变量，并且返回了对被保护变量的引用，这样的行为就是闭包。

例子：函数内部定义一个函数

由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，可能导致内存泄露，解决方法是，在退出函数之前，将不使用的局部变量全部删除。

2、内存管理
JS 环境中分配的内存有如下生命周期：

1.内存分配：当我们声明变量、函数、对象的时候，系统会自动为他们分配内存
2.内存使用：即读写内存，也就是使用变量、函数等
3. 内存回收：使用完毕，由垃圾回收机制自动回收不再使用的内存

JS 垃圾回收的机制
1.引用计数垃圾收集
缺点：引用计数算法是个简单有效的算法。但它却存在一个致命的问题：循环引用。
如果两个对象相互引用，尽管他们已不再使用，垃圾回收不会进行回收，导致内存泄露。

2.标记清除算法

标记清除算法将“不再使用的对象”定义为“无法达到的对象”。 简单来说，就是从根部（在JS中就是全局对象）出发定时扫描内存中的对象。 凡是能从根部到达的对象，都是还需要使用的。 那些无法由根部出发触及到的对象被标记为不再使用，稍后进行回收。

工作流程：
1.垃圾收集器会在运行的时候会给存储在内存中的所有变量都加上标记。
2.从根部出发将能触及到的对象的标记清除。
3.那些还存在标记的变量被视为准备删除的变量。
4.最后垃圾收集器会执行最后一步内存清除的工作，销毁那些带标记的值并回收它们所占用的内存空间。

3.JavaScript V8 引擎的垃圾回收机制
Scavenge 算法，按照 经典的 Cheney 算法 实现的
清除 或 紧缩 算法
增量标记 与 惰性清除


内存泄漏的识别方法
经验法则是，如果连续五次垃圾回收之后，内存占用一次比一次大，就有内存泄漏。 这就要求实时查看内存的占用情况。

常见的内存泄露案例
1.意外的全局变量
2.被遗忘的定时器和回调函数
3.闭包
4.DOM 引用

如何避免内存泄漏
记住一个原则：不用的东西，及时归还。
1.减少不必要的全局变量，使用严格模式避免意外创建全局变量。
2.在你使用完数据后，及时解除引用（闭包中的变量，dom引用，定时器清除）。
3.组织好你的逻辑，避免死循环等造成浏览器卡顿，崩溃的问题。


3、原型链和原型范式
原型是什么？
原型是一个prototype对象，用于表示对象之间的关系。
原型链
每个实例对象（ object ）都有一个私有属性（称之为 proto ）指向它的构造函数的原型对象（prototype ）。该原型对象也有一个自己的原型对象( proto ) ，层层向上直到一个对象的原型对象为 null。根据定义，null 没有原型，就作为这个原型链中的最后一个环节。以上一整个原型与原型层层相链接的过程即为原型链
实际应用：原型链主要用于继承，其实就是为了代码复用。

4、new,call,apply,bind方法的实现原理
New：	1: 获取构造函数
* 2：创建一个新对象；
* 3：将函数的作用域赋给新对象（这里实际上就是生产了一个新的上下文）
* 4：执行函数中的代码（为新对象添加属性、方法）
* 5：返回值，无返回值或者返回一个非对象值时，则将创建的新对象返回，否则会将返回值作为新对象返回。


都会改变this指向
Call ， apply， 都差不多，最主要的是参数不同，一个是多个对象，一个是数组，bind是返回一个函数，不会立即执行


5、判断JS数据类型的四种方法
typeof    返回的结果用该类型的字符串(全小写字母)形式表示，包括以下 7 种：number、boolean、symbol、string、object、undefined、function 等。

instanceof
instanceof 是用来判断 A 是否为 B 的实例，表达式为：A instanceof B，如果 A 是 B 的实例，则返回 true,否则返回 false。

当 A 的 __proto__ 指向 B 的 prototype 时，就认为 A 就是 B 的实例，

constructor
函数的 constructor 是不稳定的，这个主要体现在自定义对象上，当开发者重写 prototype 后，原有的 constructor 引用会丢失，constructor 会默认为 Object

toString
Object.prototype.toString.call('');  // [object String]

6.e.target和e.currentTarget之间的区别
事件捕获：js中事件执行的整个过程称之为事件流，分为三个阶段：事件捕获阶段，事件目标处理函数、事件冒泡。

事件捕获阶段：事件从最上一级标签开始往下查找，直到捕获到事件目标(target)。
事件冒泡阶段：事件从事件目标(target)开始，往上冒泡直到页面的最上一级标签。

> target是事件触发的真实元素
> currentTarget是事件绑定的元素
> 事件处理函数中的this指向是中为currentTarget
> currentTarget和target，有时候是同一个元素，有时候不是同一个元素 （因为事件冒泡）
> 当事件是子元素触发时，currentTarget为绑定事件的元素，target为子元素
> 当事件是元素自身触发时，currentTarget和target为同一个元素。

7、深拷贝
function clone(target) {
    if (typeof target === 'object') {
        let cloneTarget = Array.isArray(target) ? [] : {};
        for (const key in target) {
            cloneTarget[key] = clone(target[key]);
        }
        return cloneTarget;
    } else {
        return target;
    }
};

深拷贝和浅拷贝是只针对Object和Array这样的引用数据类型的。

浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

https://segmentfault.com/a/1190000018874254


8、promise内部实现方式
function Promise(extutor){
 
  function resolve(value){
  } 
  function reject(reason){
  } 
  try{
    excutor(resolve, reject)
  } catch(e) {
    reject(e)
  }
}

Promise.prototype.then = function(onFulfilled, onRejected){
}

https://www.jianshu.com/p/8d3bd325e886


9、

10、强缓存和协商缓存
1、基本原理
* 1）浏览器在加载资源时，根据请求头的expires和cache-control判断是否命中强缓存，是则直接从缓存读取资源，不会发请求到服务器。
* 2）如果没有命中强缓存，浏览器一定会发送一个请求到服务器，通过last-modified和etag验证资源是否命中协商缓存，如果命中，服务器会将这个请求返回，但是不会返回这个资源的数据，依然是从缓存中读取资源
* 3）如果前面两者都没有命中，直接从服务器加载资源
2、相同点
如果命中，都是从客户端缓存中加载资源，而不是从服务器加载资源数据；
3、不同点
强缓存不发请求到服务器，协商缓存会发请求到服务器。

Access-Control-Max-Age：缓存可以被缓存的时间

11、http 2.0
1.二进制分帧层
HTTP2性能提升的核心就在于二进制分帧层。HTTP2是二进制协议，他采用二进制格式传输数据而不是1.x的文本格式。

2.多路复用
HTTP2让所有的通信都在一个TCP连接上完成，真正实现了请求的并发
3.头部压缩
HTTP2为此采用HPACK压缩格式来压缩首部。头部压缩需要在浏览器和服务器端之间：
* 维护一份相同的静态字典，包含常见的头部名称，以及常见的头部名称和值的组合
* 维护一份相同的动态字典，可以动态的添加内容
* 通过静态Huffman编码对传输的首部字段进行编码

4.服务器推送  服务器端推送使得服务器可以预测客户端需要的资源，主动推送到客户端。

12、前端安全性
####XSS
>DOM型xss

>反射型xss

>存储型xss

解决方案
>过滤。

>编码

>httpOnly, 在cookie中设置HttpOnly属性，使js脚本无法读取到cookie信息。

####CSRF
>CSRF全称(Cross-Site Request Forgeries)跨站请求伪造。指攻击者冒充用户发起请求（在用户不知情的情况下），完成一些违背用户意愿的事情

解决方案
>使用token

>Referer 验证

>使用验证码

####点击劫持
>点击劫持就是将一个危险网站设置透明，然后在其上方设置一个按钮，当你点击这个按钮的时候，就会触发底部恶意网站的某些事件。

解决方案
>设置http响应头 X-Frame-Options

>使用CSP(Content Security Policy)内容安全策略

####不安全的第三方依赖
>现如今进行应用开发，无论是后端服务器应用还是前端应用开发，绝大多数时候我们都是在借助开发框架和各种类库进行快速开发。然而，一些第三方的依赖或者插件存在很多安全性问题，也会存在这样那样的漏洞，所以使用起来得谨慎。

解决方案
>尽量减少第三方依赖，选用相对成熟的依赖包。

>使用自动化工具检查这些第三方代码有没有安全问题，比如NSP(Node Security Platform)，Snyk等等。

####本地存储数据泄露
很多开发者为了方便，把一些个人信息不经加密直接存到本地或者cookie，这样是非常不安全的，黑客们可以很容易就拿到用户的信息。
解决方案
>不在本地存储重要数据,敏感、机密信息不要存储在本地。

>加密,所有在放到cookie中的信息或者localStorage里的信息要进行加密，加密可以自己定义一些加密方法或者网上寻找一些加密的插件，或者用base64进行多次加密然后再多次解码。

>https://juejin.im/post/6844903942036389895


13、js 线程、宏观任务、微观任务、运行机制梳理

js同步异步的区别
>同步就是所有的任务都处在同一队列中，不可以插队，一个任务执行完接着开始执行下一个，相对于浏览器而言，同步的效率过低，一些耗费时间比较长的任务应该用异步来执行。

>异步就是将一个任务放入到异步队列中，当这个任务执行完成之后，再从异步队列中提取出来，插队到同步队列中，拿到异步任务的结果，可以提升代码执行的效率，不需要因为一个耗费时长的代码而一直等待。

宏任务包括有：setTimeOut、setInterval、setImmediate、I/O、用户交互操作，UI渲染
微任务包括有：Promise(重点)、process.nextTick(nodejs)、Object.observe(不推荐使用)

为什么要使用 process.nextTick()?
有两个主要原因：
1. 允许用户处理错误，清理任何不需要的资源，或者在事件循环继续之前重试请求。  
2. 有时有让回调在栈展开后，但在事件循环继续之前运行的必要 

微任务和宏任务在Node的执行顺序
Node 10以前：
* 		执行完一个阶段的所有任务
* 		执行完nextTick队列里面的内容
* 		然后执行完微任务队列的内容
Node 11以后：
* 		和浏览器的行为统一了，都是每执行一个宏任务就执行完微任务队列。


https://zhuanlan.zhihu.com/p/78113300

14、dns解析的过程
>DNS，就是Domain Name System的缩写，翻译过来就是域名系统，是互联网上作为域名和IP地址相互映射的一个分布式数据库。
>DNS能够使用户更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。
>通过域名，最终得到该域名对应的IP地址的过程叫做域名解析（或主机名解析）。

为什么需要DNS解析域名为IP地址？ 
>网络通讯大部分是基于TCP/IP的，而TCP/IP是基于IP地址的，所以计算机在网络上进行通讯时只能识别如“202.96.134.133”之类的IP地址，而不能认识域名。
>我们无法记住10个以上IP地址的网站，所以我们访问网站时，更多的是在浏览器地址栏中输入域名，就能看到所需要的页面，这是因为有一个叫“DNS服务器”的计算机自动把我们的域名“翻译”成了相应的IP地址，然后调出IP地址所对应的网页。

>https://www.zhihu.com/question/23042131


15、hybrid怎么跟APP通信
Hybrid App（混合模式移动应用）是指介于web-app、native-app这两者之间的app，兼具" Native App良好用户交互体验的优势 "和" Web App跨平台开发的优势 "。

>H5 + JSBridge，通过JSBridge完成H5和Native的通信，赋予H5一定的端能力。是一种基于WebView UI的解决方案。

>React-Native，进一步通过JSbridge将js解析为虚拟DOM传递到Native，并使用原生进行渲染。

>小程序解决方案，采用双线程的渲染机制，将渲染层WebView和逻辑层JavaScriptCore形成独立的模块，通过Native进行通信（setData），逻辑层的网络请求也会由Native进行转发。在UI方面，采用的是WebView和原生相结合的方式。


16、new  set（）方法的使用
>Set和Map主要的应用场景在于数组去重和数据存储
set
>Set实例的属性和方法
 
Set的属性：
>集合是由一组无序且唯一(即不能重复)的项组成的，可以想象成集合是一个既没有重复元素，也没有顺序概念的数组

size：返回集合所包含元素的数量

Set的方法：

操作方法
>add(value)：向集合添加一个新的项

>delete(value)：从集合中移除一个值

>has(value)：如果值在集合中存在，返回true,否则false

>clear(): 移除集合里所有的项
 
遍历方法
>keys()：返回一个包含集合中所有键的数组

>values()：返回一个包含集合中所有值的数组

>entries：返回一个包含集合中所有键值对的数组(感觉没什么用就不实现了)

>forEach()：用于对集合成员执行某种操作，没有返回值

Map:

集合又和字典有什么区别呢：

>共同点：集合、字典可以存储不重复的值

>不同点：集合是以[值，值]的形式存储元素，字典是以[键，值]的形式存储

Map的属性和方法

属性：

size：返回字典所包含的元素个数

操作方法：

>set(key, val): 向字典中添加新元素

>get(key):通过键值查找特定的数值并返回

>has(key):如果键存在字典中返回true,否则false

>delete(key): 通过键值从字典中移除对应的数据

>clear():将这个字典中的所有元素删除

遍历方法：

>keys():将字典中包含的所有键名以数组形式返回

>values():将字典中包含的所有数值以数组形式返回

>forEach()：遍历字典的所有成员

17、向服务器发起TCP的3次握手
https://hit-alibaba.github.io/interview/basic/network/TCP.html



18、jsbridge的实现原理
https://juejin.cn/post/6844903585268891662
JSBridge 要实现的主要逻辑就出现了：通信调用（Native 与 JS 通信） 和 句柄解析调用

19.加密方式
1.aes，des
2.base64
3.md5

20.箭头函数与普通函数的区别？
https://juejin.cn/post/6844904184446189576
1.语法更加简洁、清晰
2.箭头函数没有 prototype (原型)，所以箭头函数本身没有this 
3.箭头函数不会创建自己的this
4.call | apply | bind 无法改变箭头函数中this的指向
5.箭头函数不能作为构造函数使用
6.箭头函数不绑定arguments，取而代之用rest参数...代替arguments对象，来访问箭头函数的参数列表
7.箭头函数不能用作Generator函数，不能使用yield关键字


21.js中this的绑定与丢失
https://blog.csdn.net/qq_22855325/article/details/76267925

1.new绑定
new方式是优先级最高的一种调用方式，只要是使用new方式来调用一个构造函数，this一定会指向new调用函数新创建的对象。
2.显式绑定
显示绑定指的是通过call()和apply()方法，强制指定某些对象对函数进行调用，this则强制指向调用函数的对象。
3.隐式绑定
隐式绑定是指通过为对象添加属性，该属性的值即为要调用的函数，进而使用该对象调用函数。
4.默认绑定
默认绑定是指当上面这三条绑定规则都不符合时，默认绑定会把this指向全局对象window


1.隐式丢失
当进行隐式绑定时，如果进行一次引用赋值或者传参操作，会造成this的丢失，使this绑定到全局对象中去。
1.1引用赋值丢失
1.2传参丢失
1.3隐式丢失解决方法

2.间接引用
3.ES6箭头函数


